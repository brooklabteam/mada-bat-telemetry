aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude") +
annotation_scale()
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# load data
points.df <- read.csv('telem_111423.csv', header = TRUE)
View(points.df)
rm(points.df)
# load data
points.df <- read.csv('telem_111423.csv', header = TRUE)
View(points.df)
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier)
# for calculating trajectories and home ranges.
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
library(sp)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
# Transform the point object (points.sp)
points.sp.geo <- spTransform(points.sp, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
# Plot study site using ggmap
library(ggmap)
## Satellite imagery
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 9, maptype = 'satellite')
ggmap(mybasemap)
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(id = points.sp.geo@data$individual.local.identifier, # add individual identifier
points.sp.geo@coords) # Add coordinates
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths
View(points.geo)
View(points.geo)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 5, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 8, maptype = 'satellite')
ggmap(mybasemap)
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 7, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 9, maptype = 'satellite')
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, fill = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, fill = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
mymap.paths
mymap.paths + labs(linetype='Bat ID')
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
library(adehabitatHR) # Load library
# Calculate MCPs for each turtle
points.df.mcp <- mcp(points.sp, percent = 100)
# Examine output
points.df.mcp
# Plot
library(scales) # Helps make polygons partly transparent using the alpha argument below
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
hrs # examine dataframe
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
# Download tiles using ggmap
library(ggmap)
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.spgeo@coords[,1]),
lat = mean(points.spgeo@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$individual.local.identifier. )
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
# Plot
library(scales) # Helps make polygons partly transparent using the alpha argument below
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
library(adehabitatHR)
kernel.ref <- kernelUD(points.sp, h = "href")  # href = the reference bandwidth
image(kernel.ref) # plot
kernel.ref[[1]]@h # The smoothing factor is stored for each animal in the "h" slot
kernel.lscv <- kernelUD(points.sp, h = "LSCV") # Least square cross validation smoothing
image(kernel.lscv) # plot
plotLSCV(kernel.lscv) # Look for a dip
points.kernel.poly.95 <- getverticeshr(kernel.ref, percent = 95)
points.kernel.poly.50 <- getverticeshr(kernel.ref, percent = 50)
print(points.kernel.poly)  # returns the area of each polygon
plot(points.kernel.poly.50, col = as.factor(points.kernel.poly@data$id))
plot(points.kernel.poly.50, col = as.factor(points.kernel.poly.50@data$id))
plot(points.kernel.poly.95)
plot(points.sp, add = TRUE, col = as.factor(points.kernel.poly@data$id), pch = 21)
plot(points.sp, add = TRUE, col = as.factor(points.kernel.poly.95@data$id), pch = 21)
library(maptools)
install.packages(maptools)
install.packages('maptools')
library(sp)
library(gganimate)
library(ggmap)
library(dplyr)
library(magrittr)
library(gifski)
View(points.df)
# Make sure points are in order (in case they weren't before)
points.df <- points.df %>%
arrange(individual.local.identifier., timestamp) %>% # arrange by animal, and ascending date
filter(!is.na(location.long), !is.na(location.lat)) # remove NA's
# Make sure points are in order (in case they weren't before)
points.df <- points.df %>%
arrange(individual.local.identifier, timestamp) %>% # arrange by animal, and ascending date
filter(!is.na(location.long), !is.na(location.lat)) # remove NA's
# Make spatial
points.sp <- points.df
coordinates(points.sp) <- c("location.long", "location.lat")
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
# Make back into dataframe (but include date for our animation)
# ggmap and gganimate use dataframes for plotting
points.geo <- as.data.frame(points.sp@coords)
points.geo$id <- points.sp@data$individual.local.identifier # add individual identifier
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m-%d-%Y %H:%M") # Important! the variable for revealing in the animation must be
View(points.geo)
points.geo$date <- as.POSIXct(points.sp@data$timestamp) # Important! the variable for revealing in the animation must be
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m/%d/%Y %H:%M") # Important! the variable for revealing in the animation must be
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m/%d/%y %H:%M") # Important! the variable for revealing in the animation must be
# Download tiles using ggmap
library(ggmap)
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]),
lat = mean(points.sp@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
# Plot static imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = location.long, y = location.lat, colour = as.character(id))) +
geom_path(data = points.geo, aes(x = location.long, y = location.lat, colour = as.character(id), group = as.character(id))) +
labs(x = "Longitude", y = "Latitude") +
#scale_colour_manual(name = "Bat ID",
# Adjust the number of values for how many animals you have
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink"),
# Enough breaks for every animal in the data set
#                  breaks = unique(as.character(points.geo$id))) +
theme(legend.position = "bottom")
# Static plot
mymap.paths
# Update plot to animate. I used 'transition_reveal' so that the path builds from the beginning to the end. Use 'transition_states' to show only one point at a time
path.animate.plot <- mymap.paths +
transition_reveal(along = date) +
labs(title = 'Date: {frame_along}')  # Add a label on top to say what date each frame is
# To display the animation, use `animate`.
# When using your own data, adjust frames per second (fps) to be as fast or slow as you like.
# Be patient at this stage! It will eventually render in your plotting window
animate(path.animate.plot,
fps = 5, renderer = gifski_renderer())
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
warnings()
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# set wd
wd <- setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# set wd
homedir <- "/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode"
setwd(homedir)
# load data
# update to most recent
points.df <- read.csv(paste0(homedir,"/Input/Movebank-AllTags-AllSensorTypes-06072024.csv", header = TRUE))
# load data
# update to most recent
points.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv", header = TRUE))
paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv",
paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv")
)
paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv")
# load data
# update to most recent
points.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv"), header = TRUE)
View(points.df)
test.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv"), header = TRUE)
# separate date and time
test.df$Date <- as.Date(test.df$timestamp)
View(test.df)
test.df$Time <- format(test.df$timestamp,"%H:%M:%S")
class(test.df$timestamp)
# convert timestamp column and separate data and time
strptime(test.df$timestamp, "%Y-%m-%d %H:%M:%S")
# convert timestamp column and separate data and time
test.df$timestamp <- strptime(test.df$timestamp, "%Y-%m-%d %H:%M:%S")
test.df$Date <- as.Date(test.df$timestamp)
test.df$Time <- format(test.df$timestamp,"%H:%M:%S")
# add column for daytime or nighttime
test.df$day <- NA
for(i in 1:length(test.df$Time)){
if(test.df[i,]$Time > "07:00:00" & test.df[i,]$Time < "13:00:00"){
test.df$day = 1
}
else{
test.df$day = 0
}
}
test.df[1,]$Time
test.df[2,]$Time
class(test.df[i,]$Time)
as.numeric(test.df[i,]$Time)
as.numeric(test.df[1,]$Time)
for(i in 1:length(test.df$Time)){
if(test.df[i,]$Time > "07:00:00" && test.df[i,]$Time < "13:00:00"){
test.df$day = 1
}
else{
test.df$day = 0
}
}
test.df[1,]$Time
as.numeric(test.df[1,]$Time)
strptime(test.df[1,]$Time,"%H:%M:%S")
test.df$Time <- as.POSIXct(test.df$Time, format = "%H:%M:%S")
class(test.df$Time)
for(i in 1:length(test.df$Time)){
if(test.df[i,]$Time > "07:00:00" && test.df[i,]$Time < "13:00:00"){
test.df$day = 1
}
else{
test.df$day = 0
}
}
dawn <- as.POSIXct("07:00:00", format = "%H:%M:%S")
library(lubridate)
# convert timestamp column
(test.df$Time <- mdy_hms(test.df$Time))
# convert timestamp column
(test.df$Time <- ymd_hms(test.df$Time))
# convert timestamp column
(test.df$timestamp <- ymd_hms(test.df$timestamp))
test.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv"), header = TRUE)
is.na(test.df$timestamp)
count(is.na(test.df$timestamp))
sum(is.na(test.df$timestamp))
# convert timestamp column
(test.df$timestamp <- ymd_hms(test.df$timestamp))
class(test.df$timestamp)
# change time zone to Madagascar
test.df$timestamp <- with_tz(test.df$timestamp, "Madagascar")
grep("Madagascar", OlsonNames(), value=TRUE)
OlsonNames()
# change time zone to Madagascar
test.df$timestamp <- with_tz(test.df$timestamp, "Africa/Addis_Ababa")
#--------------------------------------------------------------------------------------------
## FORMAT FOR SPATIAL ANALYSIS
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
#--------------------------------------------------------------------------------------------
## LOAD DATA
points.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv"), header = TRUE)
# The dataframe should only have 3 columns (x, y, and an identifier) for home ranges
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
library(sp)
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
coordinates(points.sp) <- c("location.long", "location.lat")
View(points.sp)
#--------------------------------------------------------------------------------------------
## FORMAT FOR SPATIAL ANALYSIS
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier) for home ranges
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
View(points.sp)
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
# Transform the point object (points.sp)
points.sp.geo <- spTransform(points.sp, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
library(ggmap)
## Satellite imagery
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 9, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 2, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 5, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 6, maptype = 'satellite')
ggmap(mybasemap)
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(id = points.sp.geo@data$individual.local.identifier, # add individual identifier
points.sp.geo@coords) # Add coordinates
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
library(adehabitatHR)
# Calculate MCPs for each turtle
points.df.mcp <- mcp(points.sp, percent = 100)
# Calculate MCPs for each bat
points.df.mcp <- mcp(points.sp, percent = 100)
View(points.sp)
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Only include three columns (id, x, and y coordinates) for making MCP's
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
coordinates(points.sp) <- c("location.long", "location.lat")
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
# Calculate MCPs for each turtle
points.df.mcp <- mcp(points.sp, percent = 100)
table(points.df$individual.local.identifier)
# drop any that have less than 5 data points
points.df[!(points.df$individual.local.identifier %in% "LOR002"),]
# drop any that have less than 5 data points
points.df <- points.df[!(points.df$individual.local.identifier %in% "LOR002"),]
# counts per bat
table(points.df$individual.local.identifier)
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier) for home ranges
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
# Calculate MCPs for each bat with more than 5 relocations
points.df.mcp <- mcp(points.sp, percent = 100)
# Examine output
points.df.mcp
library(scales)
# Plot
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
hrs # examine dataframe
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
library(maptools)
# plot on google map
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.spgeo@coords[,1]),
lat = mean(points.spgeo@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
mybasemap <- get_map(location = c(lon = mean(points.spgeo@coords[,1]),
lat = mean(points.spgeo@coords[,2])),
source = "google",
zoom = 6,
maptype = 'satellite')
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
kernel.ref <- kernelUD(points.sp, h = "href")  # href = the reference bandwidth
image(kernel.ref) # plot
kernel.ref[[1]]@h # The smoothing factor is stored for each animal in the "h" slot
kernel.lscv <- kernelUD(points.sp, h = "LSCV") # Least square cross validation smoothing
image(kernel.lscv) # plot
plotLSCV(kernel.lscv) # Look for a dip
points.kernel.poly.95 <- getverticeshr(kernel.ref, percent = 95)
points.kernel.poly.50 <- getverticeshr(kernel.ref, percent = 50)
print(points.kernel.poly)  # returns the area of each polygon
print(points.kernel.poly.50)  # returns the area of each polygon
plot(points.kernel.poly.50, col = as.factor(points.kernel.poly.50@data$id))
