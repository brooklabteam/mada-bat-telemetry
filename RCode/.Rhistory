# Tag ID : 58558
# Argos ID : 245092
# Deployment Start: 2023-09-11
# Deployment End :
maro114 <- read.table('DSA_Con_245092_231018124044.txt', skip=2, sep=",")
colnames(maro114) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
maro114 = maro114[,1:7]
maro114$Date <- as.Date(maro114$Date, format = "%d/%m/%Y")
# add id column
maro114$Tag.ID. <- '58558'
maro114$Argos.ID. <- '245092'
maro114$Bat.ID. <- 'MARO114'
# subset to each deployment
# MARO115
# Tag ID : 58565
# Argos ID : 245099
# Deployment Start: 2023-09-11
# Deployment End :
maro115 <- read.table('DSA_Con_245099_231018124044.txt', skip=2, sep=",")
colnames(maro115) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
maro115 = maro115[,1:7]
maro115$Date <- as.Date(maro115$Date, format = "%d/%m/%Y")
# add id column
maro115$Tag.ID. <- '58565'
maro115$Argos.ID. <- '245099'
maro115$Bat.ID. <- 'MARO115'
# subset to each deployment
# TSI092
# Tag ID : 58559
# Argos ID : 245093
# Deployment Start: 2023-09-07
# Deployment End :
tsi092 <- read.table('DSA_Con_245092_231018124044.txt', skip=2, sep=",")
colnames(tsi092) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
tsi092 = tsi092[,1:7]
tsi092$Date <- as.Date(tsi092$Date, format = "%d/%m/%Y")
# add id column
tsi092$Tag.ID. <- '58559'
tsi092$Argos.ID. <- '245093'
tsi092$Bat.ID. <- 'TSI092'
# subset to each deployment
# TSI093
# Tag ID : 58562
# Argos ID : 245096
# Deployment Start: 2023-09-09
# Deployment End :
tsi093 <- read.table('DSA_Con_245096_231018124044.txt', skip=2, sep=",")
colnames(tsi093) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
tsi093 = tsi093[,1:7]
tsi093$Date <- as.Date(tsi093$Date, format = "%d/%m/%Y")
# add id column
tsi093$Tag.ID. <- '58562'
tsi093$Argos.ID. <- '245096'
tsi093$Bat.ID. <- 'TSI093'
## bind together
points.df.all <- rbind(ana139, ana140, ana154, maro113, maro114, maro115, tsi092, tsi093)
points.df.OK <- points.df.all[which(points.df.all$CRC == '           OK'),]
## export cleaned data
write.csv(points.df.OK, "/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode/pruf_morsub_argos_all.csv")
View(points.df.OK)
#deployment
ana140 <- ana140[which(ana140$Date >= "2023-08-23"),]
## This script takes in Argos raw data and subsets it based on
## deployments, to only include relevant data.
# Run this before generating plots
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode/Argostest")
## subset to each deployment
## ANA139
## Tag ID : 58557
## Argos ID : 245091
## Deployment Start: 2023-08-23
## Deployment End :
# id subset
ana139 <- read.table('DSA_Con_245091_231018124044.txt', skip=2, sep=",")
colnames(ana139) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
ana139 = ana139[,1:7]
ana139$Date <- as.Date(ana139$Date, format = "%d/%m/%Y")
# add id column
ana139$Tag.ID. <- '58557'
ana139$Argos.ID. <- '245091'
ana139$Bat.ID. <- 'ANA139'
#deployment (occasionally date errors in Argos data)
ana139 <- ana139[which(ana139$Date >= "2023-08-23"),]
# ANA140
# Tag ID : 58556
# Argos ID : 245090
# Deployment Start: 2023-08-23
# Deployment End :
# id subset
ana140 <- read.table('DSA_Con_245090_231018124044.txt', skip=2, sep=",")
colnames(ana140) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
ana140 = ana140[,1:7]
ana140$Date <- as.Date(ana140$Date, format = "%d/%m/%Y")
# add id column
ana140$Tag.ID. <- '58556'
ana140$Argos.ID. <- '245090'
ana140$Bat.ID. <- 'ANA140'
#deployment
ana140 <- ana140[which(ana140$Date >= "2023-08-23"),]
# subset to each deployment
# ANA154
# Tag ID : 58563
# Argos ID : 245097
# Deployment Start: 2023-10-01
# Deployment End :
ana154 <- read.table('DSA_Con_245097_231018124044.txt', skip=2, sep=",")
colnames(ana154) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
ana154 = ana154[,1:7]
ana154$Date <- as.Date(ana154$Date, format = "%d/%m/%Y")
# add id column
ana154$Tag.ID. <- '58563'
ana154$Argos.ID. <- '245097'
ana154$Bat.ID. <- 'ANA154'
# add deployment
ana154 <- ana154[which(ana154$Date >= "2023-10-01"),]
# MARO113
# Tag ID : 58564
# Argos ID : 245098
# Deployment Start: 2023-09-11
# Deployment End :
maro113 <- read.table('DSA_Con_245098_231018124044.txt', skip=2, sep=",")
colnames(maro113) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
maro113 = maro113[,1:7]
maro113$Date <- as.Date(maro113$Date, format = "%d/%m/%Y")
# add id column
maro113$Tag.ID. <- '58564'
maro113$Argos.ID. <- '245098'
maro113$Bat.ID. <- 'MARO113'
#deployment
maro113 <- maro113[which(maro113$Date >= "2023-09-11"),]
# MARO114
# Tag ID : 58558
# Argos ID : 245092
# Deployment Start: 2023-09-11
# Deployment End :
maro114 <- read.table('DSA_Con_245092_231018124044.txt', skip=2, sep=",")
colnames(maro114) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
maro114 = maro114[,1:7]
maro114$Date <- as.Date(maro114$Date, format = "%d/%m/%Y")
# add id column
maro114$Tag.ID. <- '58558'
maro114$Argos.ID. <- '245092'
maro114$Bat.ID. <- 'MARO114'
#deployment
maro114 <- maro114[which(maro114$Date >= "2023-09-11"),]
# subset to each deployment
# MARO115
# Tag ID : 58565
# Argos ID : 245099
# Deployment Start: 2023-09-11
# Deployment End :
maro115 <- read.table('DSA_Con_245099_231018124044.txt', skip=2, sep=",")
colnames(maro115) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
maro115 = maro115[,1:7]
maro115$Date <- as.Date(maro115$Date, format = "%d/%m/%Y")
# add id column
maro115$Tag.ID. <- '58565'
maro115$Argos.ID. <- '245099'
maro115$Bat.ID. <- 'MARO115'
# deployment
maro115 <- maro115[which(maro115$Date >= "2023-09-11"),]
# subset to each deployment
# TSI092
# Tag ID : 58559
# Argos ID : 245093
# Deployment Start: 2023-09-07
# Deployment End :
tsi092 <- read.table('DSA_Con_245092_231018124044.txt', skip=2, sep=",")
colnames(tsi092) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
tsi092 = tsi092[,1:7]
tsi092$Date <- as.Date(tsi092$Date, format = "%d/%m/%Y")
# add id column
tsi092$Tag.ID. <- '58559'
tsi092$Argos.ID. <- '245093'
tsi092$Bat.ID. <- 'TSI092'
# deployment
tsi092 <- tsi092[which(tsi092$Date >= "2023-09-07"),]
# subset to each deployment
# TSI093
# Tag ID : 58562
# Argos ID : 245096
# Deployment Start: 2023-09-09
# Deployment End :
tsi093 <- read.table('DSA_Con_245096_231018124044.txt', skip=2, sep=",")
colnames(tsi093) = c("CRC", "Date", "Time", "Latitude", "Longitude", "Fix", "Alt(m)")
tsi093 = tsi093[,1:7]
tsi093$Date <- as.Date(tsi093$Date, format = "%d/%m/%Y")
# add id column
tsi093$Tag.ID. <- '58562'
tsi093$Argos.ID. <- '245096'
tsi093$Bat.ID. <- 'TSI093'
# deployment
tsi093 <- tsi093[which(tsi093$Date >= "2023-09-09"),]
## bind together
points.df.all <- rbind(ana139, ana140, ana154, maro113, maro114, maro115, tsi092, tsi093)
points.df.OK <- points.df.all[which(points.df.all$CRC == '           OK'),]
## export cleaned data
write.csv(points.df.OK, "/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode/pruf_morsub_argos_all.csv")
View(points.df.OK)
# Creating minimum convex polygons from telemetry data
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# load data
points.df <- read.csv('pruf_morsub_argos_all.csv', header = TRUE)
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$Latitude) & !is.na(points.df$Longitude),]
View(points.df)
# Only include three columns (id, x, and y coordinates) for making MCP's
points.sp <- points.df[, c("Bat.ID.", "Longitude", "Latitude")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
library(sp)
coordinates(points.sp) <- c("Longitude", "Latitude")
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
library(adehabitatHR) # Load library
# Calculate MCPs for each turtle
points.df.mcp <- mcp(points.sp, percent = 100)
# Examine output
points.df.mcp
# Plot
library(scales) # Helps make polygons partly transparent using the alpha argument below
plot(points.sp, col = as.factor(points.sp@data$Bat.ID.), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
hrs # examine dataframe
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
# Download tiles using ggmap
library(ggmap)
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.spgeo@coords[,1]),
lat = mean(points.spgeo@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$Bat.ID. )
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude") +
annotation_scale()
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
rm(list=ls())
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# load data
points.df <- read.csv('telem_111423.csv', header = TRUE)
View(points.df)
rm(points.df)
# load data
points.df <- read.csv('telem_111423.csv', header = TRUE)
View(points.df)
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier)
# for calculating trajectories and home ranges.
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
library(sp)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
# Transform the point object (points.sp)
points.sp.geo <- spTransform(points.sp, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
# Plot study site using ggmap
library(ggmap)
## Satellite imagery
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 9, maptype = 'satellite')
ggmap(mybasemap)
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(id = points.sp.geo@data$individual.local.identifier, # add individual identifier
points.sp.geo@coords) # Add coordinates
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths
View(points.geo)
View(points.geo)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 5, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 8, maptype = 'satellite')
ggmap(mybasemap)
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 7, maptype = 'satellite')
ggmap(mybasemap)
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 9, maptype = 'satellite')
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, fill = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, fill = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80), legend.title = 'Bat ID') +
labs(x = "Longitude", y = "Latitude")
mymap.paths
mymap.paths + labs(linetype='Bat ID')
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
library(adehabitatHR) # Load library
# Calculate MCPs for each turtle
points.df.mcp <- mcp(points.sp, percent = 100)
# Examine output
points.df.mcp
# Plot
library(scales) # Helps make polygons partly transparent using the alpha argument below
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
hrs # examine dataframe
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
# Download tiles using ggmap
library(ggmap)
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.spgeo@coords[,1]),
lat = mean(points.spgeo@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$individual.local.identifier. )
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
# Plot
library(scales) # Helps make polygons partly transparent using the alpha argument below
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
library(adehabitatHR)
kernel.ref <- kernelUD(points.sp, h = "href")  # href = the reference bandwidth
image(kernel.ref) # plot
kernel.ref[[1]]@h # The smoothing factor is stored for each animal in the "h" slot
kernel.lscv <- kernelUD(points.sp, h = "LSCV") # Least square cross validation smoothing
image(kernel.lscv) # plot
plotLSCV(kernel.lscv) # Look for a dip
points.kernel.poly.95 <- getverticeshr(kernel.ref, percent = 95)
points.kernel.poly.50 <- getverticeshr(kernel.ref, percent = 50)
print(points.kernel.poly)  # returns the area of each polygon
plot(points.kernel.poly.50, col = as.factor(points.kernel.poly@data$id))
plot(points.kernel.poly.50, col = as.factor(points.kernel.poly.50@data$id))
plot(points.kernel.poly.95)
plot(points.sp, add = TRUE, col = as.factor(points.kernel.poly@data$id), pch = 21)
plot(points.sp, add = TRUE, col = as.factor(points.kernel.poly.95@data$id), pch = 21)
library(maptools)
install.packages(maptools)
install.packages('maptools')
library(sp)
library(gganimate)
library(ggmap)
library(dplyr)
library(magrittr)
library(gifski)
View(points.df)
# Make sure points are in order (in case they weren't before)
points.df <- points.df %>%
arrange(individual.local.identifier., timestamp) %>% # arrange by animal, and ascending date
filter(!is.na(location.long), !is.na(location.lat)) # remove NA's
# Make sure points are in order (in case they weren't before)
points.df <- points.df %>%
arrange(individual.local.identifier, timestamp) %>% # arrange by animal, and ascending date
filter(!is.na(location.long), !is.na(location.lat)) # remove NA's
# Make spatial
points.sp <- points.df
coordinates(points.sp) <- c("location.long", "location.lat")
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
# Make back into dataframe (but include date for our animation)
# ggmap and gganimate use dataframes for plotting
points.geo <- as.data.frame(points.sp@coords)
points.geo$id <- points.sp@data$individual.local.identifier # add individual identifier
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m-%d-%Y %H:%M") # Important! the variable for revealing in the animation must be
View(points.geo)
points.geo$date <- as.POSIXct(points.sp@data$timestamp) # Important! the variable for revealing in the animation must be
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m/%d/%Y %H:%M") # Important! the variable for revealing in the animation must be
points.geo$date <- as.POSIXct(points.sp@data$timestamp, format = "%m/%d/%y %H:%M") # Important! the variable for revealing in the animation must be
# Download tiles using ggmap
library(ggmap)
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]),
lat = mean(points.sp@coords[,2])),
source = "google",
zoom = 9,
maptype = 'satellite')
# Plot static imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = location.long, y = location.lat, colour = as.character(id))) +
geom_path(data = points.geo, aes(x = location.long, y = location.lat, colour = as.character(id), group = as.character(id))) +
labs(x = "Longitude", y = "Latitude") +
#scale_colour_manual(name = "Bat ID",
# Adjust the number of values for how many animals you have
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink"),
# Enough breaks for every animal in the data set
#                  breaks = unique(as.character(points.geo$id))) +
theme(legend.position = "bottom")
# Static plot
mymap.paths
# Update plot to animate. I used 'transition_reveal' so that the path builds from the beginning to the end. Use 'transition_states' to show only one point at a time
path.animate.plot <- mymap.paths +
transition_reveal(along = date) +
labs(title = 'Date: {frame_along}')  # Add a label on top to say what date each frame is
# To display the animation, use `animate`.
# When using your own data, adjust frames per second (fps) to be as fast or slow as you like.
# Be patient at this stage! It will eventually render in your plotting window
animate(path.animate.plot,
fps = 5, renderer = gifski_renderer())
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
warnings()
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
# set wd
setwd("/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode")
# Save as gif. This may be a large file, depending on your data set!
anim_save(path.animate.plot,
file = "animatedpaths.gif")
