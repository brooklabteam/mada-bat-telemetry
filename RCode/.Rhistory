points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier) for home ranges
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
# Transform the point object (points.sp)
points.sp.geo <- spTransform(points.sp, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
## Satellite imagery
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 6, maptype = 'satellite')
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(id = points.sp.geo@data$individual.local.identifier, # add individual identifier
points.sp.geo@coords) # Add coordinates
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), pch = 4) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), pch = 4) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 4) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 1) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 0.2) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 0.5) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 1) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
# Calculate MCPs for each bat
points.df.mcp <- mcp(points.sp, percent = 95) # after Epstein et al
# Examine output
points.df.mcp
# Plot
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$individual.local.identifier. )
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$individual.local.identifier. )
# Calculate MCPs for each bat
points.df.mcp <- mcp(points.sp, percent = 95) # after Epstein et al
# Examine output
points.df.mcp
# Plot
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
plot(points.df.mcp, col = alpha(1:7, 0.5), add = TRUE)
# Calculate the MCP by including 50 to 100 percent of points
hrs <- mcp.area(points.sp, percent = seq(50, 100, by = 5))
hrs # examine dataframe
# Transform the point and MCP objects.
points.spgeo <- spTransform(points.sp, CRS("+proj=longlat"))
points.mcpgeo <- spTransform(points.df.mcp, CRS("+proj=longlat"))
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(points.spgeo@coords,
id = points.spgeo@data$individual.local.identifier. )
mymap.hr <- ggmap(mybasemap) +
geom_polygon(data = fortify(points.mcpgeo),
# Polygon layer needs to be "fortified" to add geometry to the dataframe
aes(long, lat, colour = id, fill = id),
alpha = 0.3) + # alpha sets the transparency
geom_point(data = points.geo,
aes(x = coords.x1, y = coords.x2, colour = as.character(id)))  +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
#scale_fill_manual(name = "Bat ID",
#                 values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093")) +
#scale_colour_manual(name = "Bat ID",
#                   values = c("red", "blue", "purple", "green", "orange", "black", "pink", "yellow"),
#                  breaks = c("ANA139", "ANA140", "ANA154", "MARO113", "MARO114", "MARO115", "TSI092", "TSI093"))
mymap.hr
# This script takes in MoveBank telemetry downloads, cleans and preps, then generates figures
rm(list=ls())
library(lubridate)
library(sp)
library(ggmap)
library(adehabitatHR)
library(scales)
library(maptools)
library(ggmap)
library(dplyr)
#--------------------------------------------------------------------------------------------
## SET WD
homedir <- "/Users/sophiahorigan/Documents/GitHub/mada-bat-telemetry/RCode"
setwd(homedir)
#--------------------------------------------------------------------------------------------
## LOAD DATA
points.df <- read.csv(paste0(homedir,"/input/Movebank-AllTags-AllSensorTypes-06072024.csv"), header = TRUE)
# cleanup
# convert timestamp column
points.df$timestamp <- ymd_hms(points.df$timestamp)
# change time zone to Madagascar
points.df$timestamp <- with_tz(points.df$timestamp, "Africa/Addis_Ababa")
# add site column
points.df <- points.df %>%
mutate(site = case_when(grepl("MAN", individual.local.identifier) ~ 'Ambositra - P',
grepl("ANA", individual.local.identifier) ~ 'Analambotaka - P',
grepl("TSI", individual.local.identifier) ~ 'Marotsipohy - P',
grepl("MARO", individual.local.identifier) ~ 'Marovitsika - P',
grepl("HAR", individual.local.identifier) ~ 'Nosy Hara - P',
grepl("KEL", individual.local.identifier) ~ 'Angavokely - E',
grepl("LOR", individual.local.identifier) ~ 'Ambositra - E',
grepl("NAT", individual.local.identifier) ~ 'Mangroves - P',
grepl("VHL", individual.local.identifier) ~ 'Vahialava - P',
grepl("KEL", individual.local.identifier) ~ 'Angavokely - E',
grepl("WAY", individual.local.identifier) ~ 'Ankarana - E'))
table(points.df$individual.local.identifier)
# drop any that have less than 5 data points (right now just 1)
points.df <- points.df[!(points.df$individual.local.identifier %in% "LOR002"),]
#--------------------------------------------------------------------------------------------
## DAY VS NIGHT
dusk_hour = 18 # made up
dawn_hour = 5
points.df <- points.df %>%
mutate(daytime = ifelse(hour(timestamp) < dusk_hour & hour(timestamp) > dawn_hour, "day", "night"))
points.df %>%
group_by(individual.taxon.canonical.name)  %>%
count(daytime)
daytime.df <- points.df[, c("individual.local.identifier", "site", "daytime", "location.long", "location.lat")]
# by individual
ggplot(data = daytime.df, aes(location.long, location.lat)) +
geom_point(aes(colour = daytime)) +
facet_wrap(individual.local.identifier ~ ., scales = 'free')
# by site
ggplot(data = daytime.df, aes(location.long, location.lat)) +
geom_point(aes(colour = daytime)) +
facet_wrap(site ~ ., scales = 'free')
# color by site shape by individual
# could larger daytime movement indicate a more disturbed roost??????!
ggplot(data = daytime.df, aes(location.long, location.lat)) +
geom_point(aes(colour = daytime), shape = as.factor(daytime.df$individual.local.identifier)) +
facet_wrap(site ~ ., scales = 'free')
#--------------------------------------------------------------------------------------------
## SEASON
May = 5 # from Andrianiaina et al 2022
October = 10
points.df <- points.df %>%
mutate(season = ifelse(month(timestamp) < May | month(timestamp) > October, "wet", "dry"))
points.df %>%  # both species
count(season)
points.df %>%  # by species
group_by(individual.taxon.canonical.name)  %>%
count(season)
season.df <- points.df[, c("individual.local.identifier", "site", "season", "location.long", "location.lat")]
# by individual bat
ggplot(data = season.df, aes(location.long, location.lat)) +
geom_point(aes(colour=season)) +
facet_wrap(individual.local.identifier ~ ., scales = 'free')
# group by site
ggplot(data = season.df, aes(location.long, location.lat)) +
geom_point(aes(colour=season)) +
facet_wrap(site ~ ., scales = 'free')
# group by site shape by individual
ggplot(data = season.df, aes(location.long, location.lat)) +
geom_point(aes(colour = season), shape = as.factor(season.df$individual.local.identifier)) +
facet_wrap(site ~ ., scales = 'free')
#--------------------------------------------------------------------------------------------
## MONTH
points.df %>%
count(month(timestamp)) # both species
points.df %>%
group_by(individual.taxon.canonical.name)  %>%
count(month(timestamp)) # by species
# make df with just tag id, start and end of deployment
# interval of tag activity
tag_interval <- start %--% end # NEEDS TO BE FIXED TO BE FOR EACH TAG ID
# To format for spatial analyses, we need to remove NA values from the coordinate columns
points.df <- points.df[!is.na(points.df$location.lat) & !is.na(points.df$location.long),]
# The dataframe should only have 3 columns (x, y, and an identifier) for home ranges
points.sp <- points.df[, c("individual.local.identifier", "location.long", "location.lat")]
# Turn into a spatial points dataframe (class: SpatialPointsDataFrame)
coordinates(points.sp) <- c("location.long", "location.lat")
# Examine the structure of our SpatialPointsDataFrame
str(points.sp)
# Set coordinate system & projection
crs_wgs84 <- CRS(SRS_string = "EPSG:4326") # WGS 84 has EPSG code 4326
class(crs_wgs84)
slot(points.sp, "proj4string") <- crs_wgs84
plot(points.sp, col = as.factor(points.sp@data$individual.local.identifier), pch = 16)
# Transform the point object (points.sp)
points.sp.geo <- spTransform(points.sp, CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
## Satellite imagery
register_google(key = "AIzaSyCwa0OOmg7nRXgOrBZgBxgvmdn1h_bIO7g")
## The location argument can take a vector with latitude and longitude, or a character string.
mybasemap <- get_map(location = c(lon = mean(points.sp@coords[,1]) ,
lat = mean(points.sp@coords[,2])),
source = "google", zoom = 6, maptype = 'satellite')
ggmap(mybasemap)
# Turn the spatial data frame of points into just a dataframe for plotting in ggmap
points.geo <- data.frame(id = points.sp.geo@data$individual.local.identifier, # add individual identifier
points.sp.geo@coords) # Add coordinates
# Plot imagery + points + paths
mymap.paths <-ggmap(mybasemap) +
geom_point(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id)), size = 1) +
geom_path(data = points.geo, aes(x = coords.x1, y = coords.x2, colour = as.factor(id))) +
theme(legend.position = c(0.15, 0.80)) +
labs(x = "Longitude", y = "Latitude")
mymap.paths + labs(linetype='Bat ID')
mymap.paths
kernel.ref <- kernelUD(points.sp, h = "href")  # href = the reference bandwidth
image(kernel.ref) # plot
kernel.ref[[1]]@h # The smoothing factor is stored for each animal in the "h" slot
kernel.lscv <- kernelUD(points.sp, h = "LSCV") # Least square cross validation smoothing
warnings()
plotLSCV(kernel.lscv) # Look for a dip
points.kernel.poly.95 <- getverticeshr(kernel.ref, percent = 95)
points.kernel.poly.50 <- getverticeshr(kernel.ref, percent = 50)
image(kernel.ref) # plot
kernel.ref[[1]]@h # The smoothing factor is stored for each animal in the "h" slot
points.kernel.poly.95 <- getverticeshr(kernel.ref, percent = 95)
# set domain
x <- seq(1,100,by=1.)
y <- seq(1,100,by=1.)
xy <- expand.grid(x=x,y=y)
coordinates(xy) <- ~x+y
gridded(xy) <- TRUE
class(xy)
# calculate kernal densities
kernal.ref <- kernalUD(points.sp, h = "href", grid = xy)
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href", grid = xy)
image(kernel.ref)
# set domain
x <- seq(1,100,by=.5)
y <- seq(1,100,by=.5)
xy <- expand.grid(x=x,y=y)
coordinates(xy) <- ~x+y
gridded(xy) <- TRUE
class(xy)
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href", grid = xy)
# set domain
x <- seq(1,1000,by=.5)
y <- seq(1,1000,by=.5)
xy <- expand.grid(x=x,y=y)
coordinates(xy) <- ~x+y
gridded(xy) <- TRUE
class(xy)
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href", grid = xy)
# set domain
x <- seq(1,1000,by=.25)
y <- seq(1,1000,by=.25)
xy <- expand.grid(x=x,y=y)
coordinates(xy) <- ~x+y
gridded(xy) <- TRUE
class(xy)
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href", grid = xy)
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href")
image(kernel.ref)
# get volume
kernel.vud <- getvolumeUD(kernel.ref)
# get contour
levels <- c(50, 75, 95)
list <- vector(mode = "list", length = 2)
list[[1]] <- as.image.SpatialGridDataFrame(kernel.vud[[1]])
list[[2]] <- as.image.SpatialGridDataFrame(kernel.vud[[2]])
# plot
par(mfrow = c(2,1))
image(kernel.vud[[1]])
contour(list[[1]], add = TRUE, levels = levels)
image(kernel.vud[[2]])
contour(list[[2]], add = TRUE, levels = levels)
plot(kernel.vud[[1]])
plot(kernel.vud)
[[1]]
plot(kernel.vud[[1]])
View(kernel.vud)
kernal.vud
kernel.vud
length(kernel.vud)
# get contour
levels <- c(25, 50, 75, 95, 100)
list <- vector(mode = "list", length = length(kernel.vud))
for (i in 1:length(kernel.vud)){
list[[i]] <- as.image.SpatialGridDataFrame(kernel.vud[[i]])
}
# plot
par(mfrow = c(6,4))
for (i in 1:length(kernel.vud)){
plot(kernel.vud[[i]])
contour(list[[i]], add = TRUE, levels = levels)
}
# plot
par(mfrow = c(6,4))
for (i in 1:length(kernel.vud)){
plot(kernel.vud[[i]])
contour(list[[i]], add = TRUE, levels = levels)
}
View(points.df)
ggmap(mybasemap, extent="normal") +
geom_density2d(data = points.df, aes(x=location.long, y=location.lat, group=individual.local.identifier, colour=individual.local.identifier))
warnings()
ggmap(mybasemap, extent="normal") +
geom_density2d(data = points.df, aes(x=location.long, y=location.lat, group=site, colour=site))
ggplot(kernel.vud[[1]])
ggplot(data = kernel.vud[[1]])
View(kernel.vud)
## HOME RANGES
# home ranges in vector mode
homerange <- getverticeshr(points.sp)
## HOME RANGES
# home ranges in vector mode
homerange <- getverticeshr(kernel.ref)
## KERNAL DENSITIES
# calculate kernal densities
kernel.ref <- kernelUD(points.sp, h = "href")
## HOME RANGES
# home ranges in vector mode
homerange <- getverticeshr(kernel.ref)
## HOME RANGES
# home ranges in vector mode
homerange <- kernel.area(kernel.ref, percent = seq(50, 95, by=5))
View(homerange)
plot(homerange)
library(amt)
# Make an amt `track` object with our sample data set
points_track <- points.df %>%
# Remove NA x and y rows
filter(!is.na(location.lat), !is.na(location.long)) %>%
# Make track with coordinates, date-time, id
make_track(location.long, location.lat, timestamp, id = individual.local.identifier,
# Make sure to specify coordinate reference system (CRS)
crs = "EPSG:4326") %>%
# Use nest() to allow us to deal with multiple animals (5 in sample set)
# Each animal's track is stored in a tibble (table) nested within the data column
nest(data = -"id") %>%
arrange(id)
# Examine object. It is a tibble with a row for each individual.
#The value of 'data' contains the nested track_xyt object for each individual
points_track
# Examine one individual's track
head(points_track$data[1])
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(1.0))))
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(.5))))
sf_use_s2(FALSE)
library(sf)
sf_use_s2(FALSE)
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(1.0))))
sf_use_s2(TRUE)
poly2nb(st_make_valid(prov))
library(spdep)
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(1.0))))
install.pacakges("lwgeom")
install.packages(lwgeom)
View(points_track)
# remove duplicates
test <- unique(points.df)
# remove duplicates
test <- unique(points_track)
test <- points.df %>% distinct(location.lat, location.lat, .keep_all = TRUE)
View(test)
# Make an amt `track` object with our sample data set
points_track <- test %>%
# Remove NA x and y rows
filter(!is.na(location.lat), !is.na(location.long)) %>%
# Make track with coordinates, date-time, id
make_track(location.long, location.lat, timestamp, id = individual.local.identifier,
# Make sure to specify coordinate reference system (CRS)
crs = "EPSG:4326") %>%
# Use nest() to allow us to deal with multiple animals (5 in sample set)
# Each animal's track is stored in a tibble (table) nested within the data column
nest(data = -"id") %>%
arrange(id)
test <- points.df %>% distinct(location.lat, location.lat, .keep_all = TRUE)
# Examine object. It is a tibble with a row for each individual.
#The value of 'data' contains the nested track_xyt object for each individual
points_track
# Examine one individual's track
head(points_track$data[1])
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(1.0))))
# Each id's MCP is stored in the list column "mcp"
# Check by plotting the first one
plot(points_track$mcp[[1]])
# Add MCP list-column to track using `map`
points_track <- points_track %>%
mutate(mcp = map(data, function(x)
# levels are for which proportions (1.0 = 100%)
x %>% hr_mcp(levels = c(1.0))))
# Each id's MCP is stored in the list column "mcp"
# Check by plotting the first one
plot(points_track$mcp[[1]])
# Calculate overlap between T002 (row 2) and T004 (row 4)
# labels are from ID in track object
# overlap is fraction of overlap between two home ranges
hr_overlap(points_track$mcp[[2]],
points_track$mcp[[4]],
labels = points_track$id[c(2,4)],
type = "hr")
# Calculate overlap between all
points_hr_overlap <- hr_overlap(points_track$mcp,
labels = points_track$id,
which = "all",
# alternative which = "consecutive",
# "one_to_all"
conditional = FALSE)
# Look at first 10 comparisons
head(points_hr_overlap, n = 10)
points_hr_overlap
# Make a track of the data that is not nested.
points_track_nonest <- points.df %>%
dplyr::select(location.lat, location.long, timestamp, individual.local.identifier) %>%
make_track(location.lat, location.long, timestamp, id = individual.local.identifier,
# Make sure to specify coordinate reference system (CRS)
crs = sp::CRS("+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs"))
# Make a track of the data that is not nested.
points_track_nonest <- points.df %>%
dplyr::select(location.lat, location.long, timestamp, individual.local.identifier) %>%
make_track(location.lat, location.long, timestamp, id = individual.local.identifier)
points_track_nonest <- points.df %>%
# Remove NA x and y rows
make_track(location.long, location.lat, timestamp, id = individual.local.identifier,
# Make sure to specify coordinate reference system (CRS)
crs = "EPSG:4326")
# Make a base raster for whole study. Without this common raster,
# each Kernel Density Estimator will likely use different pixel sizes and
# output of hr_overlap will be blank.
base_trast <- make_trast(points_track_nonest,
res = 50)
# Calculate the kernel density estimator for two turtles at 95%
hr_245091 <- hr_kde(points_track$data[2][[1]], trast = base_trast, levels = 0.95)
hr_245093 <- hr_kde(points_track$data[4][[1]], trast = base_trast, levels = 0.95)
hr_overlap(hr_245091, hr_245093, type = "vi", conditional = FALSE)
